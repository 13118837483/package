<?php

namespace app\index\controller;

use app\index\model\Product;
use app\index\model\Test;
use think\Controller;
use think\Request;

class TestController extends Controller
{
    protected $mod = null;

    function __construct(Request $request = null)
    {
        parent::__construct($request);
        //
        $this->mod = new Test();

    }
    //面试Md
    /**
     * get跟post区别
     * 1.get传参在url中  post传参在request body  在请求体
     * 2.get传参长度有限制  post没有
     * 3.get在浏览器退回的时候是无害的 post会再次请求
     * 4.get传参在url中所以不能存在敏感信息  post不会
     */


    /**
     * session跟cookie
     * HTTP是无状态的 服务器无法判断用户身份  所以需要用到cookie进行记录
     * 流程： 用户进入浏览器 浏览器进入服务器 服务器发送一个cookie给浏览器  作为用户标识符  当浏览器下次进入服务器时  会把cookie带过去给到服务器 服务器通过cookie识别到用户的信息
     * cookie特点
     * 1.cookie在服务端创建
     * 2.cookie保存在客户端
     * 3.cookie可以被多个浏览器共享
     * 4.cookie应当进行加密 不加密默认是明文形式 所以不加密就不应当存放敏感数据
     *
     * session特点
     * session是存放在服务端的 例如处理用户登录等操作
     * 流程：浏览器第一次请求服务器时  服务器会自动生成一个sessionid 并且存放起来  一般默认是三十分钟 并把sessionid待回给浏览器 再一次请求的时候就会将两次的sessionid进行对来判断用户登录限制
     * session特点
     * 1.sesion是存放在服务器内存中
     * 2.一个用户的浏览器  独享一个session对象
     * 3.服务器能够为不同的浏览器提供不同的session
     * 区别：
     * 1.session保存在服务器内存中 cookie保存在浏览器中
     * 2.cookie中的value是字符串形式  session中的value是对象
     * 3.生命周期不一样：cookie在浏览器关闭时候就消亡
     *
     * 打印客户端ip跟服务端ip
     * $_SERVER["SERVER_ADDR"]
     * $_SERVER["REMOTE_ADDR"]
     *
     * 优化MYSQL方法
     * 1.使用join连接来代替子查询
     * 2.避免使用select*
     * 3.合理使用索引
     * 4.使用内联合union来代替手动创建临时表
     * 5.避免隐式转换导致索引失效
     *
     * 对于大流量网站 如何优化
     * 1.负载均衡，流量分流到不同服务器
     * 2.控制大文件下载
     * 3.数据库使用读写分流 一主多从
     * 4.定位慢查询进行优化
     * 5.使用缓存避免频繁访问数据库
     *
     *
     *
     * MySQL常见的存储引擎InnoDB、MyISAM的区别
     *
     * 1.myisam不支持事务 innodb支持事务
     * 2.myisam储存数据总行数   innodb不存储
     * 3.myisam支持表级锁   innodb支持表锁 行锁
     * 4.MyISAM适合：插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择， 没有事务。
     * 5.InnoDB适合：可靠性要求比较高，或者要求事务；表更新和查询都相当的频繁， 大量的INSERT或UPDATE
     * 6.myisam索引树为非聚集索引（叶子节点的存放的是数据的文件地址）  innodb是聚集索引（叶子节点存放的是数据本身）
     *
     *
     * mysql为什么使用B+tree
     * hash：虽然可以快速定位，但是没有顺序，IO复杂度高。
     * 二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。
     * 红黑树：树的高度随着数据量增加而增加，IO代价高。
     * B+TREE始终只有三层 而且是有序的 找寻起来速度较快而且io代价不高
     *
     *
     *PHP中include和require的区别详解
     * include 引入文件的时候，如果碰到错误，会给出提示，并继续运行下边的代码。---wainning错误 --需要用到的时候才需要加载 _once 代表已经加载过得文件就不需要再次加载了
     * require 引入文件的时候，如果碰到错误，会给出提示，并停止运行下边的代码。---error错误 ---一开始就进行加载
     *
     *
     * 事务四大特性（ACID）原子性、一致性、隔离性、持久性
     * 原子性：一个事务中所有操作  要么全部完成  要么全部不完成
     * 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作
     * 持久性: 事务处理结束后 对数据的修改是永久性的
     * 隔离性：可以多个事务并行而且互不干扰--四大隔离级别
     *     读未提交 A事务在还没有提交的过程中  读取到B事务未提交的对数据进行修改的诗句
     *     读已提交 A事务在还没有提交的过程中  读取到B事务已经提交了的数据
     *     串行化 ： 每个事务串行执行 --一个一个执行
     *     可重复度：A事务在没有提交的过程中  查询到的数据是一样的（无论B事务是否对这条数据已经修改并且提交）
     *
     * 三范式：
     *  1.数据库表中的所有字段值都是不可分解的原子值
     *  2.在第一的基础上更上一层 每一列都与主键有关系
     *  3.在第一跟第二的基础上 更上一层  每一列都跟主键有直接的关系  而不是间接关系
     *.PHP 中传值与传引用的区别。什么时候传值什么时候传引用？
       按值传递：函数范围内对值的任何改变在函数外部都会被忽略
       按引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改
     *
     *
     *
     * redis
     *五种类型：  list  string  hash set  zset
     *
     * 缓存穿透 缓存雪崩  缓存击穿
     *   缓存雪崩： 同一时间内 缓存里的数据全部过期  请求全部打到数据库上面来  解决方案 --针对过期时间--热点数据不过期  或者设置一个随机的过期时间
     *   缓存击穿： 大量用户访问同一条数据  缓存没有该数据  大量请求打到数据库上面来  解决方案--设置互斥锁（第一个进来在缓存内没有拿到数据  设置锁  拿到数据放入缓存再释放锁
     *   缓存穿透： 数据在缓存没有  在数据库也没有  解决方案--设置一个值 再缓存上   用户不至于一直去请求数据库
     *
     * redis跟memcache的区别
     * 1.前者支持五中类型  后者只有一种类型
     * 2.前者可以持久化存在于磁盘中  后面只存在于内存上
     * 3.前者是单线程  后者是多线程
     * 4.前者支持分布式集群  后者不支持
     *
     *
     *
     * redis线程问题
     * 是单线程-- 优势在于不需要考虑到线程切换从而消耗的资源
     * 不需要考虑死锁而导致的性能问题
     *
     * 主从复制思想
     *
     * redis 是单线程为什么还会很快
     * 1.纯内存访问
        数据存放在内存中，内存的响应时间大概是100纳秒，这是redis每秒万亿级别访问的重要基础

        2.非阻塞I/O多路复用机制
        redis采用epoll实现的I/O多路复用，加上redis自身的事件处理模型，将epoll中的连接、读写、关闭转换为了事件，
        避免了在I/O上浪费时间

        3.单线程避免了线程的切换和竞争产生的消耗
     *
     * redis-- epoll 多路复用
     *监听多个请求--创建 等待
     * 1.纯内存访问
    数据存放在内存中，内存的响应时间大概是100纳秒，这是redis每秒万亿级别访问的重要基础

    2.非阻塞I/O多路复用机制
    redis采用epoll实现的I/O多路复用，加上redis自身的事件处理模型，将epoll中的连接、读写、关闭转换为了事件，
    避免了在I/O上浪费时间

    3.单线程避免了线程的切换和竞争产生的消耗
     *
     *
     * redis 持久化问题：
     * RDB:
     * AOF:
     *
     *
     *
     * redis 跟其他队列的区别例如NSQ
     *
     * redis适合当一些计时器的东西 不适合一些重要的消息的处理
     * 因为如果redis宕机  或者消费失败  从数据库取出来的那一刻  就当是消费了 对于一些消费失败的   会造成消息丢失
     *
     *
     *
     * mysql  过程---
     * 1、我们在客户端发起一个SQL的查询；

    2、连接器判断用户登录以及用户权限；

    3、缓存命中，走缓存，直接返回查询结果；

    3、缓存没命中，到达分析器，对SQL语句进行分析，包括预处理与解析过程；

    4、优化器，对SQL语句进行优化；

    5，执行器，调用存储引擎，执行具体的SQL操作；

    6，将操作记录在undo log中，并存储回滚段指针和事务ID。

    7，通过索引查找数据

    8，写入redo log

    9，写binlog

    10，提交事务
     *NSQ
     * nsqd是一个守护进程，它接收、排队并向客户端发送消息（负责存储数据）
     * nsqlookupd是维护所有nsqd状态、提供服务发现的守护进程。它能为消费者查找特定topic下的nsqd提供了运行时的自动发现服务
     * nsqlookupd是NSQ的一个助手进程，提供了字典式的查询服务。消费者可以通过nsqlookd查询他们感兴趣订阅的topic所对应的nsqd实例的地址
     *
     *
     * PHP请求过程  youta.cn--浏览器输入   DNS解析得到域名以及端口  NGINX监听端口识别到是PHP请求  交给PHP-FPM进程管理器
     * FPM fork出多个子进程--以锁的方式争抢 请求到PHP 得到结果返回给web服务器 然后给到用户
     *
     * nginx--代理服务器
     * 正向代理--代理客户端  客户端 通过代理服务器 去拿到服务器的内容  代理服务器代替客户端去请求服务器
     * 反向代理--代理服务端 反向代理隐藏了真实的服务端
     *
     *
     *
     *
     *
     */









    /**
     * @return void
     * 面试测试
     */
    public function testFunciton()
    {
        $b = Request::instance()->session();
        halt($_SERVER);
        $data = $this->mod->with(['product'])->limit(100)->select();
        return json($data);
    }

    public function upload()
    {
        // 获取表单上传文件 例如上传了001.jpg
        $file = request()->file('image');//image为前端表单的名字
        // 移动到框架应用根目录/public/uploads/ 目录下
        if ($file) {
            $info = $file->move(ROOT_PATH . 'public' . DS . 'uploads');
            if ($info) {
                // 成功上传后 获取上传信息
                // 输出 jpg
                echo $info->getExtension();
                // 输出 20160820/42a79759f284b767dfcb2a0197904287.jpg
                echo $info->getSaveName();
                // 输出 42a79759f284b767dfcb2a0197904287.jpg
                echo $info->getFilename();
            } else {
                // 上传失败获取错误信息
                //echo $file->getError();}}
            }

        }
    }
}